# Autogenerated using ProtocolBuffers.jl v0.1.0 on 2022-08-08T12:13:57.860
# original file: /Users/david/Projects/rai-sdk-julia/src/proto/schema.proto (proto3 syntax)

import ProtocolBuffers as PB
using ProtocolBuffers: OneOf
using EnumX: @enumx

export PrimitiveType, RelInt128, Kind, RelUInt128, PrimitiveValue, RelTuple, RelType, ConstantType, RelationId, ValueType
# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractRelType" end
abstract type var"##AbstractConstantType" end
abstract type var"##AbstractRelationId" end
abstract type var"##AbstractValueType" end


@enumx PrimitiveType UNSPECIFIED_TYPE=0 INT_128=1 INT_64=2 INT_32=3 INT_16=4 INT_8=5 UINT_128=6 UINT_64=7 UINT_32=8 UINT_16=9 UINT_8=10 FLOAT_64=11 FLOAT_32=12 FLOAT_16=13 CHAR=14 BOOL=15 STRING=16 SYMBOL=17 VARIABLE_SIZE_STRING=18

struct RelInt128
    highbits::UInt64
    lowbits::UInt64
end
PB.default_values(::Type{RelInt128}) = (;highbits = zero(UInt64), lowbits = zero(UInt64))
PB.field_numbers(::Type{RelInt128}) = (;highbits = 1, lowbits = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelInt128})
    highbits = zero(UInt64)
    lowbits = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            highbits = PB.decode(d, UInt64)
        elseif field_number == 2
            lowbits = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return RelInt128(highbits, lowbits)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelInt128)
    initpos = position(e.io)
    x.highbits != zero(UInt64) && PB.encode(e, 1, x.highbits)
    x.lowbits != zero(UInt64) && PB.encode(e, 2, x.lowbits)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelInt128)
    encoded_size = 0
    x.highbits != zero(UInt64) && (encoded_size += PB._encoded_size(x.highbits, 1))
    x.lowbits != zero(UInt64) && (encoded_size += PB._encoded_size(x.lowbits, 2))
    return encoded_size
end

@enumx Kind UNSPECIFIED_KIND=0 PRIMITIVE_TYPE=1 VALUE_TYPE=2 CONSTANT_TYPE=3

struct RelUInt128
    highbits::UInt64
    lowbits::UInt64
end
PB.default_values(::Type{RelUInt128}) = (;highbits = zero(UInt64), lowbits = zero(UInt64))
PB.field_numbers(::Type{RelUInt128}) = (;highbits = 1, lowbits = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelUInt128})
    highbits = zero(UInt64)
    lowbits = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            highbits = PB.decode(d, UInt64)
        elseif field_number == 2
            lowbits = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return RelUInt128(highbits, lowbits)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelUInt128)
    initpos = position(e.io)
    x.highbits != zero(UInt64) && PB.encode(e, 1, x.highbits)
    x.lowbits != zero(UInt64) && PB.encode(e, 2, x.lowbits)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelUInt128)
    encoded_size = 0
    x.highbits != zero(UInt64) && (encoded_size += PB._encoded_size(x.highbits, 1))
    x.lowbits != zero(UInt64) && (encoded_size += PB._encoded_size(x.lowbits, 2))
    return encoded_size
end

struct PrimitiveValue
    tag::PrimitiveType.T
    value::Union{Nothing,OneOf{<:Union{RelInt128,Int64,Int32,RelUInt128,UInt64,UInt32,Float64,Float32,Bool,Vector{UInt8}}}}
end
PB.oneof_field_types(::Type{PrimitiveValue}) = (;
    value = (;int128_val=RelInt128, int64_val=Int64, int32_val=Int32, int16_val=Int32, int8_val=Int32, uint128_val=RelUInt128, uint64_val=UInt64, uint32_val=UInt32, uint16_val=UInt32, uint8_val=UInt32, float64_val=Float64, float32_val=Float32, float16_val=Float32, char_val=UInt32, bool_val=Bool, string_val=Vector{UInt8}),
)
PB.default_values(::Type{PrimitiveValue}) = (;tag = PrimitiveType.UNSPECIFIED_TYPE, int128_val = nothing, int64_val = zero(Int64), int32_val = zero(Int32), int16_val = zero(Int32), int8_val = zero(Int32), uint128_val = nothing, uint64_val = zero(UInt64), uint32_val = zero(UInt32), uint16_val = zero(UInt32), uint8_val = zero(UInt32), float64_val = zero(Float64), float32_val = zero(Float32), float16_val = zero(Float32), char_val = zero(UInt32), bool_val = false, string_val = UInt8[])
PB.field_numbers(::Type{PrimitiveValue}) = (;tag = 1, int128_val = 2, int64_val = 3, int32_val = 4, int16_val = 5, int8_val = 6, uint128_val = 7, uint64_val = 8, uint32_val = 9, uint16_val = 10, uint8_val = 11, float64_val = 12, float32_val = 13, float16_val = 14, char_val = 15, bool_val = 16, string_val = 17)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PrimitiveValue})
    tag = PrimitiveType.UNSPECIFIED_TYPE
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tag = PB.decode(d, PrimitiveType.T)
        elseif field_number == 2
            value = OneOf(:int128_val, PB.decode(d, Ref{RelInt128}))
        elseif field_number == 3
            value = OneOf(:int64_val, PB.decode(d, Int64))
        elseif field_number == 4
            value = OneOf(:int32_val, PB.decode(d, Int32))
        elseif field_number == 5
            value = OneOf(:int16_val, PB.decode(d, Int32))
        elseif field_number == 6
            value = OneOf(:int8_val, PB.decode(d, Int32))
        elseif field_number == 7
            value = OneOf(:uint128_val, PB.decode(d, Ref{RelUInt128}))
        elseif field_number == 8
            value = OneOf(:uint64_val, PB.decode(d, UInt64))
        elseif field_number == 9
            value = OneOf(:uint32_val, PB.decode(d, UInt32))
        elseif field_number == 10
            value = OneOf(:uint16_val, PB.decode(d, UInt32))
        elseif field_number == 11
            value = OneOf(:uint8_val, PB.decode(d, UInt32))
        elseif field_number == 12
            value = OneOf(:float64_val, PB.decode(d, Float64))
        elseif field_number == 13
            value = OneOf(:float32_val, PB.decode(d, Float32))
        elseif field_number == 14
            value = OneOf(:float16_val, PB.decode(d, Float32))
        elseif field_number == 15
            value = OneOf(:char_val, PB.decode(d, UInt32))
        elseif field_number == 16
            value = OneOf(:bool_val, PB.decode(d, Bool))
        elseif field_number == 17
            value = OneOf(:string_val, PB.decode(d, Vector{UInt8}))
        else
            PB.skip(d, wire_type)
        end
    end
    return PrimitiveValue(tag, value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PrimitiveValue)
    initpos = position(e.io)
    x.tag != PrimitiveType.UNSPECIFIED_TYPE && PB.encode(e, 1, x.tag)
    if isnothing(x.value);
    elseif x.value.name === :int128_val
        PB.encode(e, 2, x.value[])
    elseif x.value.name === :int64_val
        PB.encode(e, 3, x.value[])
    elseif x.value.name === :int32_val
        PB.encode(e, 4, x.value[])
    elseif x.value.name === :int16_val
        PB.encode(e, 5, x.value[])
    elseif x.value.name === :int8_val
        PB.encode(e, 6, x.value[])
    elseif x.value.name === :uint128_val
        PB.encode(e, 7, x.value[])
    elseif x.value.name === :uint64_val
        PB.encode(e, 8, x.value[])
    elseif x.value.name === :uint32_val
        PB.encode(e, 9, x.value[])
    elseif x.value.name === :uint16_val
        PB.encode(e, 10, x.value[])
    elseif x.value.name === :uint8_val
        PB.encode(e, 11, x.value[])
    elseif x.value.name === :float64_val
        PB.encode(e, 12, x.value[])
    elseif x.value.name === :float32_val
        PB.encode(e, 13, x.value[])
    elseif x.value.name === :float16_val
        PB.encode(e, 14, x.value[])
    elseif x.value.name === :char_val
        PB.encode(e, 15, x.value[])
    elseif x.value.name === :bool_val
        PB.encode(e, 16, x.value[])
    elseif x.value.name === :string_val
        PB.encode(e, 17, x.value[])
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::PrimitiveValue)
    encoded_size = 0
    x.tag != PrimitiveType.UNSPECIFIED_TYPE && (encoded_size += PB._encoded_size(x.tag, 1))
    if isnothing(x.value);
    elseif x.value.name === :int128_val
        encoded_size += PB._encoded_size(x.value[], 2)
    elseif x.value.name === :int64_val
        encoded_size += PB._encoded_size(x.value[], 3)
    elseif x.value.name === :int32_val
        encoded_size += PB._encoded_size(x.value[], 4)
    elseif x.value.name === :int16_val
        encoded_size += PB._encoded_size(x.value[], 5)
    elseif x.value.name === :int8_val
        encoded_size += PB._encoded_size(x.value[], 6)
    elseif x.value.name === :uint128_val
        encoded_size += PB._encoded_size(x.value[], 7)
    elseif x.value.name === :uint64_val
        encoded_size += PB._encoded_size(x.value[], 8)
    elseif x.value.name === :uint32_val
        encoded_size += PB._encoded_size(x.value[], 9)
    elseif x.value.name === :uint16_val
        encoded_size += PB._encoded_size(x.value[], 10)
    elseif x.value.name === :uint8_val
        encoded_size += PB._encoded_size(x.value[], 11)
    elseif x.value.name === :float64_val
        encoded_size += PB._encoded_size(x.value[], 12)
    elseif x.value.name === :float32_val
        encoded_size += PB._encoded_size(x.value[], 13)
    elseif x.value.name === :float16_val
        encoded_size += PB._encoded_size(x.value[], 14)
    elseif x.value.name === :char_val
        encoded_size += PB._encoded_size(x.value[], 15)
    elseif x.value.name === :bool_val
        encoded_size += PB._encoded_size(x.value[], 16)
    elseif x.value.name === :string_val
        encoded_size += PB._encoded_size(x.value[], 17)
    end
    return encoded_size
end

struct RelTuple
    arguments::Vector{PrimitiveValue}
end
PB.default_values(::Type{RelTuple}) = (;arguments = Vector{PrimitiveValue}())
PB.field_numbers(::Type{RelTuple}) = (;arguments = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelTuple})
    arguments = PB.BufferedVector{PrimitiveValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, arguments)
        else
            PB.skip(d, wire_type)
        end
    end
    return RelTuple(arguments[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelTuple)
    initpos = position(e.io)
    !isempty(x.arguments) && PB.encode(e, 1, x.arguments)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelTuple)
    encoded_size = 0
    !isempty(x.arguments) && (encoded_size += PB._encoded_size(x.arguments, 1))
    return encoded_size
end

struct RelType{T2<:Union{Nothing,var"##AbstractConstantType"},T1<:Union{Nothing,var"##AbstractValueType"}} <: var"##AbstractRelType"
    tag::Kind.T
    primitive_type::PrimitiveType.T
    value_type::T1
    constant_type::T2
end
PB.default_values(::Type{RelType}) = (;tag = Kind.UNSPECIFIED_KIND, primitive_type = PrimitiveType.UNSPECIFIED_TYPE, value_type = nothing, constant_type = nothing)
PB.field_numbers(::Type{RelType}) = (;tag = 1, primitive_type = 2, value_type = 3, constant_type = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelType})
    tag = Kind.UNSPECIFIED_KIND
    primitive_type = PrimitiveType.UNSPECIFIED_TYPE
    value_type = Ref{Union{Nothing,ValueType}}(nothing)
    constant_type = Ref{Union{Nothing,ConstantType}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tag = PB.decode(d, Kind.T)
        elseif field_number == 2
            primitive_type = PB.decode(d, PrimitiveType.T)
        elseif field_number == 3
            PB.decode!(d, value_type)
        elseif field_number == 4
            PB.decode!(d, constant_type)
        else
            PB.skip(d, wire_type)
        end
    end
    return RelType(tag, primitive_type, value_type[], constant_type[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelType)
    initpos = position(e.io)
    x.tag != Kind.UNSPECIFIED_KIND && PB.encode(e, 1, x.tag)
    x.primitive_type != PrimitiveType.UNSPECIFIED_TYPE && PB.encode(e, 2, x.primitive_type)
    !isnothing(x.value_type) && PB.encode(e, 3, x.value_type)
    !isnothing(x.constant_type) && PB.encode(e, 4, x.constant_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelType)
    encoded_size = 0
    x.tag != Kind.UNSPECIFIED_KIND && (encoded_size += PB._encoded_size(x.tag, 1))
    x.primitive_type != PrimitiveType.UNSPECIFIED_TYPE && (encoded_size += PB._encoded_size(x.primitive_type, 2))
    !isnothing(x.value_type) && (encoded_size += PB._encoded_size(x.value_type, 3))
    !isnothing(x.constant_type) && (encoded_size += PB._encoded_size(x.constant_type, 4))
    return encoded_size
end

struct ConstantType <: var"##AbstractConstantType"
    rel_type::Union{Nothing,RelType}
    value::Union{Nothing,RelTuple}
end
PB.default_values(::Type{ConstantType}) = (;rel_type = nothing, value = nothing)
PB.field_numbers(::Type{ConstantType}) = (;rel_type = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConstantType})
    rel_type = Ref{Union{Nothing,RelType}}(nothing)
    value = Ref{Union{Nothing,RelTuple}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, rel_type)
        elseif field_number == 2
            PB.decode!(d, value)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConstantType(rel_type[], value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConstantType)
    initpos = position(e.io)
    !isnothing(x.rel_type) && PB.encode(e, 1, x.rel_type)
    !isnothing(x.value) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConstantType)
    encoded_size = 0
    !isnothing(x.rel_type) && (encoded_size += PB._encoded_size(x.rel_type, 1))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

struct RelationId <: var"##AbstractRelationId"
    arguments::Vector{RelType}
end
PB.default_values(::Type{RelationId}) = (;arguments = Vector{RelType}())
PB.field_numbers(::Type{RelationId}) = (;arguments = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RelationId})
    arguments = PB.BufferedVector{RelType}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, arguments)
        else
            PB.skip(d, wire_type)
        end
    end
    return RelationId(arguments[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RelationId)
    initpos = position(e.io)
    !isempty(x.arguments) && PB.encode(e, 1, x.arguments)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RelationId)
    encoded_size = 0
    !isempty(x.arguments) && (encoded_size += PB._encoded_size(x.arguments, 1))
    return encoded_size
end

struct ValueType <: var"##AbstractValueType"
    argument_types::Vector{RelType}
end
PB.default_values(::Type{ValueType}) = (;argument_types = Vector{RelType}())
PB.field_numbers(::Type{ValueType}) = (;argument_types = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ValueType})
    argument_types = PB.BufferedVector{RelType}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, argument_types)
        else
            PB.skip(d, wire_type)
        end
    end
    return ValueType(argument_types[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ValueType)
    initpos = position(e.io)
    !isempty(x.argument_types) && PB.encode(e, 1, x.argument_types)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ValueType)
    encoded_size = 0
    !isempty(x.argument_types) && (encoded_size += PB._encoded_size(x.argument_types, 1))
    return encoded_size
end
